"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            },\n            generateId\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = generateId();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else if (streamedResponse.startsWith('{\"tool_calls\":')) {\n                responseMessage[\"tool_calls\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (streamedResponse.startsWith('{\"tool_calls\":')) {\n            const parsedToolCalls = JSON.parse(streamedResponse).tool_calls;\n            responseMessage[\"tool_calls\"] = parsedToolCalls;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, onResponse, onFinish, onError, credentials, headers, body, generateId = nanoid } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n        if (isComplexMode) {\n            for await (const { type, value } of readDataStream(reader, {\n                isAborted: ()=>abortController === null\n            })){\n                switch(type){\n                    case \"text\":\n                        {\n                            result += value;\n                            setCompletion(result);\n                            break;\n                        }\n                    case \"data\":\n                        {\n                            onData == null ? void 0 : onData(value);\n                            break;\n                        }\n                }\n            }\n        } else {\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                setCompletion(result);\n                if (abortController === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction experimental_useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a, _b;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify({\n                ...body,\n                // always use user-provided threadId when available:\n                threadId: (_b = threadIdParam != null ? threadIdParam : threadId) != null ? _b : null,\n                message: input,\n                // optional request data:\n                data: requestOptions == null ? void 0 : requestOptions.data\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        try {\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : \"\",\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FHQUVBLG9CQUFvQjtBQUNvRDtBQUMvQztBQUV6Qix5QkFBeUI7QUFDekIsSUFBSU0saUJBQWlCO0lBQ25CQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJRyx5QkFBeUI7SUFDM0JOLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLG9CQUFtQkEsS0FBSSxLQUFNLE9BQU9BLE1BQU1JLGFBQWEsS0FBSyxZQUFZSixNQUFNSSxhQUFhLElBQUksUUFBUSxDQUFFLFdBQVVKLE1BQU1JLGFBQWEsS0FBSyxDQUFFLGdCQUFlSixNQUFNSSxhQUFhLEtBQUssT0FBT0osTUFBTUksYUFBYSxDQUFDTixJQUFJLEtBQUssWUFBWSxPQUFPRSxNQUFNSSxhQUFhLENBQUNDLFNBQVMsS0FBSyxVQUFVO1lBQ3pVLE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05GO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSU0saUJBQWlCO0lBQ25CVCxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksQ0FBQ08sTUFBTUMsT0FBTyxDQUFDUixRQUFRO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJUyxrQkFBa0I7SUFDcEJaLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVNGO1FBQU07SUFDaEM7QUFDRjtBQUNBLElBQUlVLDZCQUE2QjtJQUMvQmIsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsU0FBUUEsS0FBSSxLQUFNLENBQUUsV0FBVUEsS0FBSSxLQUFNLENBQUUsY0FBYUEsS0FBSSxLQUFNLE9BQU9BLE1BQU1XLEVBQUUsS0FBSyxZQUFZLE9BQU9YLE1BQU1ZLElBQUksS0FBSyxZQUFZWixNQUFNWSxJQUFJLEtBQUssZUFBZSxDQUFDTCxNQUFNQyxPQUFPLENBQUNSLE1BQU1hLE9BQU8sS0FBSyxDQUFDYixNQUFNYSxPQUFPLENBQUNDLEtBQUssQ0FDeFEsQ0FBQ0MsT0FBU0EsUUFBUSxRQUFRLE9BQU9BLFNBQVMsWUFBWSxVQUFVQSxRQUFRQSxLQUFLYixJQUFJLEtBQUssVUFBVSxVQUFVYSxRQUFRQSxLQUFLQyxJQUFJLElBQUksUUFBUSxPQUFPRCxLQUFLQyxJQUFJLEtBQUssWUFBWSxXQUFXRCxLQUFLQyxJQUFJLElBQUksT0FBT0QsS0FBS0MsSUFBSSxDQUFDaEIsS0FBSyxLQUFLLFdBQzFOO1lBQ0QsTUFBTSxJQUFJQyxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJaUIsaUNBQWlDO0lBQ25DcEIsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsZUFBY0EsS0FBSSxLQUFNLENBQUUsZ0JBQWVBLEtBQUksS0FBTSxPQUFPQSxNQUFNa0IsUUFBUSxLQUFLLFlBQVksT0FBT2xCLE1BQU1tQixTQUFTLEtBQUssVUFBVTtZQUNoTCxNQUFNLElBQUlsQixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkYsT0FBTztnQkFDTGtCLFVBQVVsQixNQUFNa0IsUUFBUTtnQkFDeEJDLFdBQVduQixNQUFNbUIsU0FBUztZQUM1QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlDLHdCQUF3QjtJQUMxQnZCLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLFdBQVVBLEtBQUksS0FBTSxDQUFFLFdBQVVBLEtBQUksS0FBTSxPQUFPQSxNQUFNWSxJQUFJLEtBQUssWUFBWVosTUFBTVksSUFBSSxLQUFLLFFBQVE7WUFDckosTUFBTSxJQUFJWCxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJcUIscUJBQXFCO0lBQ3ZCeEIsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTXNCLFVBQVUsS0FBSyxZQUFZdEIsTUFBTXNCLFVBQVUsSUFBSSxRQUFRLENBQUNmLE1BQU1DLE9BQU8sQ0FBQ1IsTUFBTXNCLFVBQVUsS0FBS3RCLE1BQU1zQixVQUFVLENBQUNDLElBQUksQ0FBQyxDQUFDQztZQUMzTUEsTUFBTSxRQUFRLE9BQU9BLE9BQU8sWUFBWSxDQUFFLFNBQVFBLEVBQUMsS0FBTSxPQUFPQSxHQUFHYixFQUFFLEtBQUssWUFBWSxDQUFFLFdBQVVhLEVBQUMsS0FBTSxPQUFPQSxHQUFHdEIsSUFBSSxLQUFLLFlBQVksQ0FBRSxlQUFjc0IsRUFBQyxLQUFNQSxHQUFHQyxRQUFRLElBQUksUUFBUSxPQUFPRCxHQUFHQyxRQUFRLEtBQUssWUFBWSxDQUFFLGdCQUFlRCxHQUFHQyxRQUFRLEtBQUssT0FBT0QsR0FBR0MsUUFBUSxDQUFDM0IsSUFBSSxLQUFLLFlBQVksT0FBTzBCLEdBQUdDLFFBQVEsQ0FBQ3BCLFNBQVMsS0FBSztRQUNyVSxJQUFJO1lBQ0YsTUFBTSxJQUFJSixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJMEIsK0JBQStCO0lBQ2pDN0IsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLENBQUNPLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUTtZQUN6QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBdUJGO1FBQU07SUFDOUM7QUFDRjtBQUNBLElBQUkyQixjQUFjO0lBQ2hCL0I7SUFDQU87SUFDQUc7SUFDQUc7SUFDQUM7SUFDQU87SUFDQUc7SUFDQUM7SUFDQUs7Q0FDRDtBQUNELElBQUlFLG9CQUFvQjtJQUN0QixDQUFDaEMsZUFBZUMsSUFBSSxDQUFDLEVBQUVEO0lBQ3ZCLENBQUNPLHVCQUF1Qk4sSUFBSSxDQUFDLEVBQUVNO0lBQy9CLENBQUNHLGVBQWVULElBQUksQ0FBQyxFQUFFUztJQUN2QixDQUFDRyxnQkFBZ0JaLElBQUksQ0FBQyxFQUFFWTtJQUN4QixDQUFDQywyQkFBMkJiLElBQUksQ0FBQyxFQUFFYTtJQUNuQyxDQUFDTywrQkFBK0JwQixJQUFJLENBQUMsRUFBRW9CO0lBQ3ZDLENBQUNHLHNCQUFzQnZCLElBQUksQ0FBQyxFQUFFdUI7SUFDOUIsQ0FBQ0MsbUJBQW1CeEIsSUFBSSxDQUFDLEVBQUV3QjtJQUMzQixDQUFDSyw2QkFBNkI3QixJQUFJLENBQUMsRUFBRTZCO0FBQ3ZDO0FBQ0EsSUFBSUcsdUJBQXVCO0lBQ3pCLENBQUNqQyxlQUFlRSxJQUFJLENBQUMsRUFBRUYsZUFBZUMsSUFBSTtJQUMxQyxDQUFDTSx1QkFBdUJMLElBQUksQ0FBQyxFQUFFSyx1QkFBdUJOLElBQUk7SUFDMUQsQ0FBQ1MsZUFBZVIsSUFBSSxDQUFDLEVBQUVRLGVBQWVULElBQUk7SUFDMUMsQ0FBQ1ksZ0JBQWdCWCxJQUFJLENBQUMsRUFBRVcsZ0JBQWdCWixJQUFJO0lBQzVDLENBQUNhLDJCQUEyQlosSUFBSSxDQUFDLEVBQUVZLDJCQUEyQmIsSUFBSTtJQUNsRSxDQUFDb0IsK0JBQStCbkIsSUFBSSxDQUFDLEVBQUVtQiwrQkFBK0JwQixJQUFJO0lBQzFFLENBQUN1QixzQkFBc0J0QixJQUFJLENBQUMsRUFBRXNCLHNCQUFzQnZCLElBQUk7SUFDeEQsQ0FBQ3dCLG1CQUFtQnZCLElBQUksQ0FBQyxFQUFFdUIsbUJBQW1CeEIsSUFBSTtJQUNsRCxDQUFDNkIsNkJBQTZCNUIsSUFBSSxDQUFDLEVBQUU0Qiw2QkFBNkI3QixJQUFJO0FBQ3hFO0FBQ0EsSUFBSWlDLGFBQWFILFlBQVlJLEdBQUcsQ0FBQyxDQUFDQyxPQUFTQSxLQUFLbkMsSUFBSTtBQUNwRCxJQUFJb0Msa0JBQWtCLENBQUNDO0lBQ3JCLE1BQU1DLHNCQUFzQkQsS0FBS0UsT0FBTyxDQUFDO0lBQ3pDLElBQUlELHdCQUF3QixDQUFDLEdBQUc7UUFDOUIsTUFBTSxJQUFJbEMsTUFBTTtJQUNsQjtJQUNBLE1BQU1vQyxTQUFTSCxLQUFLSSxLQUFLLENBQUMsR0FBR0g7SUFDN0IsSUFBSSxDQUFDTCxXQUFXUyxRQUFRLENBQUNGLFNBQVM7UUFDaEMsTUFBTSxJQUFJcEMsTUFBTSxDQUFDLDRDQUE0QyxFQUFFb0MsT0FBTyxDQUFDLENBQUM7SUFDMUU7SUFDQSxNQUFNeEMsT0FBT3dDO0lBQ2IsTUFBTUcsWUFBWU4sS0FBS0ksS0FBSyxDQUFDSCxzQkFBc0I7SUFDbkQsTUFBTU0sWUFBWUMsS0FBSzNDLEtBQUssQ0FBQ3lDO0lBQzdCLE9BQU9aLGlCQUFpQixDQUFDL0IsS0FBSyxDQUFDRSxLQUFLLENBQUMwQztBQUN2QztBQUVBLDZCQUE2QjtBQUM3QixJQUFJRSxVQUFVLEtBQUtDLFVBQVUsQ0FBQztBQUM5QixTQUFTQyxhQUFhQyxNQUFNLEVBQUVDLFdBQVc7SUFDdkMsTUFBTUMscUJBQXFCLElBQUlDLFdBQVdGO0lBQzFDLElBQUlHLFNBQVM7SUFDYixLQUFLLE1BQU1DLFNBQVNMLE9BQVE7UUFDMUJFLG1CQUFtQkksR0FBRyxDQUFDRCxPQUFPRDtRQUM5QkEsVUFBVUMsTUFBTUUsTUFBTTtJQUN4QjtJQUNBUCxPQUFPTyxNQUFNLEdBQUc7SUFDaEIsT0FBT0w7QUFDVDtBQUNBLGdCQUFnQk0sZUFBZUMsTUFBTSxFQUFFLEVBQ3JDQyxTQUFTLEVBQ1YsR0FBRyxDQUFDLENBQUM7SUFDSixNQUFNQyxVQUFVLElBQUlDO0lBQ3BCLE1BQU1aLFNBQVMsRUFBRTtJQUNqQixJQUFJQyxjQUFjO0lBQ2xCLE1BQU8sS0FBTTtRQUNYLE1BQU0sRUFBRS9DLEtBQUssRUFBRSxHQUFHLE1BQU11RCxPQUFPSSxJQUFJO1FBQ25DLElBQUkzRCxPQUFPO1lBQ1Q4QyxPQUFPYyxJQUFJLENBQUM1RDtZQUNaK0MsZUFBZS9DLE1BQU1xRCxNQUFNO1lBQzNCLElBQUlyRCxLQUFLLENBQUNBLE1BQU1xRCxNQUFNLEdBQUcsRUFBRSxLQUFLVixTQUFTO2dCQUN2QztZQUNGO1FBQ0Y7UUFDQSxJQUFJRyxPQUFPTyxNQUFNLEtBQUssR0FBRztZQUN2QjtRQUNGO1FBQ0EsTUFBTUwscUJBQXFCSCxhQUFhQyxRQUFRQztRQUNoREEsY0FBYztRQUNkLE1BQU1jLGVBQWVKLFFBQVFLLE1BQU0sQ0FBQ2Qsb0JBQW9CO1lBQUVlLFFBQVE7UUFBSyxHQUFHQyxLQUFLLENBQUMsTUFBTUMsTUFBTSxDQUFDLENBQUMvQixPQUFTQSxTQUFTLElBQUlILEdBQUcsQ0FBQ0U7UUFDeEgsS0FBSyxNQUFNaUMsY0FBY0wsYUFBYztZQUNyQyxNQUFNSztRQUNSO1FBQ0EsSUFBSVYsYUFBYSxPQUFPLEtBQUssSUFBSUEsYUFBYTtZQUM1Q0QsT0FBT1ksTUFBTTtZQUNiO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsa0JBQWtCO0FBQ2lDO0FBQ25ELElBQUlFLFNBQVNELGlFQUFjQSxDQUN6QixrRUFDQTtBQUVGLFNBQVNFLG1CQUFtQkMsT0FBTztJQUNqQyxNQUFNZCxVQUFVLElBQUlDO0lBQ3BCLElBQUksQ0FBQ2EsU0FBUztRQUNaLE9BQU8sU0FBU3BCLEtBQUs7WUFDbkIsSUFBSSxDQUFDQSxPQUNILE9BQU87WUFDVCxPQUFPTSxRQUFRSyxNQUFNLENBQUNYLE9BQU87Z0JBQUVZLFFBQVE7WUFBSztRQUM5QztJQUNGO0lBQ0EsT0FBTyxTQUFTWixLQUFLO1FBQ25CLE1BQU1xQixVQUFVZixRQUFRSyxNQUFNLENBQUNYLE9BQU87WUFBRVksUUFBUTtRQUFLLEdBQUdDLEtBQUssQ0FBQyxNQUFNQyxNQUFNLENBQUMsQ0FBQy9CLE9BQVNBLFNBQVM7UUFDOUYsT0FBT3NDLFFBQVF6QyxHQUFHLENBQUNFLGlCQUFpQmdDLE1BQU0sQ0FBQ1E7SUFDN0M7QUFDRjtBQUNBLElBQUlDLGlCQUFpQjtBQUVyQixtQ0FBbUM7QUFDbkMsU0FBU0MsMkJBQTJCQyxPQUFPLEVBQUVDLFdBQVc7SUFDdEQsSUFBSSxDQUFDRCxXQUFXLENBQUNDLGVBQWUsQ0FBQ0EsWUFBWXhCLE1BQU0sRUFDakQsT0FBT3VCO0lBQ1QsT0FBTztRQUFFLEdBQUdBLE9BQU87UUFBRUMsYUFBYTtlQUFJQTtTQUFZO0lBQUM7QUFDckQ7QUFDQSxlQUFlQyxxQkFBcUIsRUFDbEN2QixNQUFNLEVBQ053QixrQkFBa0IsRUFDbEJDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxhQUFhYixNQUFNLEVBQ25CYyxpQkFBaUIsSUFBTSxhQUFhLEdBQUcsSUFBSUMsTUFBTSxFQUNsRDtJQUNDLE1BQU1DLFlBQVlGO0lBQ2xCLE1BQU1HLFlBQVk7UUFDaEJDLE1BQU0sRUFBRTtJQUNWO0lBQ0EsSUFBSUMsc0JBQXNCLEtBQUs7SUFDL0IsV0FBVyxNQUFNLEVBQUV0RixJQUFJLEVBQUVGLEtBQUssRUFBRSxJQUFJc0QsZUFBZUMsUUFBUTtRQUN6REMsV0FBVyxJQUFNLENBQUN1QixzQkFBc0IsT0FBTyxLQUFLLElBQUlBLG1CQUFtQlUsT0FBTyxNQUFNO0lBQzFGLEdBQUk7UUFDRixJQUFJdkYsU0FBUyxRQUFRO1lBQ25CLElBQUlvRixTQUFTLENBQUMsT0FBTyxFQUFFO2dCQUNyQkEsU0FBUyxDQUFDLE9BQU8sR0FBRztvQkFDbEIsR0FBR0EsU0FBUyxDQUFDLE9BQU87b0JBQ3BCekUsU0FBUyxDQUFDeUUsU0FBUyxDQUFDLE9BQU8sQ0FBQ3pFLE9BQU8sSUFBSSxFQUFDLElBQUtiO2dCQUMvQztZQUNGLE9BQU87Z0JBQ0xzRixTQUFTLENBQUMsT0FBTyxHQUFHO29CQUNsQjNFLElBQUl1RTtvQkFDSnRFLE1BQU07b0JBQ05DLFNBQVNiO29CQUNUcUY7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSUssc0JBQXNCO1FBQzFCLElBQUl4RixTQUFTLGlCQUFpQjtZQUM1Qm9GLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRztnQkFDM0IzRSxJQUFJdUU7Z0JBQ0p0RSxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUVCxlQUFlSixNQUFNSSxhQUFhO2dCQUNsQ04sTUFBTUUsTUFBTUksYUFBYSxDQUFDTixJQUFJO2dCQUM5QnVGO1lBQ0Y7WUFDQUssc0JBQXNCSixTQUFTLENBQUMsZ0JBQWdCO1FBQ2xEO1FBQ0EsSUFBSUssa0JBQWtCO1FBQ3RCLElBQUl6RixTQUFTLGNBQWM7WUFDekJvRixTQUFTLENBQUMsYUFBYSxHQUFHO2dCQUN4QjNFLElBQUl1RTtnQkFDSnRFLE1BQU07Z0JBQ05DLFNBQVM7Z0JBQ1RTLFlBQVl0QixNQUFNc0IsVUFBVTtnQkFDNUIrRDtZQUNGO1lBQ0FNLGtCQUFrQkwsU0FBUyxDQUFDLGFBQWE7UUFDM0M7UUFDQSxJQUFJcEYsU0FBUyxRQUFRO1lBQ25Cb0YsU0FBUyxDQUFDLE9BQU8sQ0FBQzFCLElBQUksSUFBSTVEO1FBQzVCO1FBQ0EsSUFBSTRGLGtCQUFrQk4sU0FBUyxDQUFDLE9BQU87UUFDdkMsSUFBSXBGLFNBQVMsdUJBQXVCO1lBQ2xDLElBQUksQ0FBQ3NGLHFCQUFxQjtnQkFDeEJBLHNCQUFzQjt1QkFBSXhGO2lCQUFNO1lBQ2xDLE9BQU87Z0JBQ0x3RixvQkFBb0I1QixJQUFJLElBQUk1RDtZQUM5QjtZQUNBMEYsc0JBQXNCZiwyQkFDcEJXLFNBQVMsQ0FBQyxnQkFBZ0IsRUFDMUJFO1lBRUZHLGtCQUFrQmhCLDJCQUNoQlcsU0FBUyxDQUFDLGFBQWEsRUFDdkJFO1lBRUZJLGtCQUFrQmpCLDJCQUNoQlcsU0FBUyxDQUFDLE9BQU8sRUFDakJFO1FBRUo7UUFDQSxJQUFJQSx1QkFBdUIsT0FBTyxLQUFLLElBQUlBLG9CQUFvQm5DLE1BQU0sRUFBRTtZQUNyRSxNQUFNd0Msb0JBQW9CO2dCQUN4QjtnQkFDQTtnQkFDQTthQUNEO1lBQ0RBLGtCQUFrQkMsT0FBTyxDQUFDLENBQUNDO2dCQUN6QixJQUFJVCxTQUFTLENBQUNTLElBQUksRUFBRTtvQkFDbEJULFNBQVMsQ0FBQ1MsSUFBSSxDQUFDbEIsV0FBVyxHQUFHOzJCQUFJVztxQkFBb0I7Z0JBQ3ZEO1lBQ0Y7UUFDRjtRQUNBLE1BQU1RLFNBQVM7WUFBQ047WUFBcUJDO1lBQWlCQztTQUFnQixDQUFDM0IsTUFBTSxDQUFDUSxTQUFTMUMsR0FBRyxDQUFDLENBQUM2QyxVQUFhO2dCQUN2RyxHQUFHRCwyQkFBMkJDLFNBQVNZLG9CQUFvQjtZQUM3RDtRQUNBUixPQUFPZ0IsUUFBUTtlQUFJVixTQUFTLENBQUMsT0FBTztTQUFDO0lBQ3ZDO0lBQ0FMLFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVNLO0lBQ3JDLE9BQU87UUFDTFcsVUFBVTtZQUNSWCxVQUFVdEUsSUFBSTtZQUNkc0UsVUFBVWxGLGFBQWE7WUFDdkJrRixVQUFVaEUsVUFBVTtTQUNyQixDQUFDMkMsTUFBTSxDQUFDUTtRQUNUYyxNQUFNRCxVQUFVQyxJQUFJO0lBQ3RCO0FBQ0Y7QUFFQSwwQkFBMEI7QUFDMUIsZUFBZVcsWUFBWSxFQUN6QkMsR0FBRyxFQUNIRixRQUFRLEVBQ1JHLElBQUksRUFDSkMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLGVBQWUsRUFDZkMsYUFBYSxFQUNiQyx3QkFBd0IsRUFDeEJDLFVBQVUsRUFDVkMsUUFBUSxFQUNSMUIsUUFBUSxFQUNSQyxVQUFVLEVBQ1g7SUFDQyxJQUFJMEI7SUFDSixNQUFNQyxXQUFXLE1BQU1DLE1BQU1YLEtBQUs7UUFDaENZLFFBQVE7UUFDUlgsTUFBTTFELEtBQUtzRSxTQUFTLENBQUM7WUFDbkJmO1lBQ0EsR0FBR0csSUFBSTtRQUNUO1FBQ0FFLFNBQVM7WUFDUCxnQkFBZ0I7WUFDaEIsR0FBR0EsT0FBTztRQUNaO1FBQ0FXLFFBQVEsQ0FBQ0wsS0FBS0wsbUJBQW1CLE9BQU8sS0FBSyxJQUFJQSxpQkFBZ0IsS0FBTSxPQUFPLEtBQUssSUFBSUssR0FBR0ssTUFBTTtRQUNoR1o7SUFDRixHQUFHYSxLQUFLLENBQUMsQ0FBQ0M7UUFDUlY7UUFDQSxNQUFNVTtJQUNSO0lBQ0EsSUFBSVQsWUFBWTtRQUNkLElBQUk7WUFDRixNQUFNQSxXQUFXRztRQUNuQixFQUFFLE9BQU9NLEtBQUs7WUFDWixNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxJQUFJLENBQUNOLFNBQVNPLEVBQUUsRUFBRTtRQUNoQlg7UUFDQSxNQUFNLElBQUl4RyxNQUNSLE1BQU00RyxTQUFTN0YsSUFBSSxNQUFNO0lBRTdCO0lBQ0EsSUFBSSxDQUFDNkYsU0FBU1QsSUFBSSxFQUFFO1FBQ2xCLE1BQU0sSUFBSW5HLE1BQU07SUFDbEI7SUFDQSxNQUFNc0QsU0FBU3NELFNBQVNULElBQUksQ0FBQ2lCLFNBQVM7SUFDdEMsTUFBTUMsZ0JBQWdCVCxTQUFTUCxPQUFPLENBQUNpQixHQUFHLENBQUM3QyxvQkFBb0I7SUFDL0QsSUFBSTRDLGVBQWU7UUFDakIsT0FBTyxNQUFNeEMscUJBQXFCO1lBQ2hDdkI7WUFDQXdCLG9CQUFvQndCLG1CQUFtQixPQUFPO2dCQUFFZCxTQUFTYztZQUFrQixJQUFJLEtBQUs7WUFDcEZ2QixRQUFRMkI7WUFDUjFCLFVBQVNLLFNBQVM7Z0JBQ2hCLElBQUlMLFlBQVlLLFVBQVV0RSxJQUFJLElBQUksTUFBTTtvQkFDdENpRSxTQUFTSyxVQUFVdEUsSUFBSTtnQkFDekI7WUFDRjtZQUNBa0U7UUFDRjtJQUNGLE9BQU87UUFDTCxNQUFNRyxZQUFZLGFBQWEsR0FBRyxJQUFJRDtRQUN0QyxNQUFNdEIsU0FBU1EsbUJBQW1CO1FBQ2xDLElBQUlrRCxtQkFBbUI7UUFDdkIsTUFBTUMsVUFBVXZDO1FBQ2hCLElBQUlVLGtCQUFrQjtZQUNwQmpGLElBQUk4RztZQUNKcEM7WUFDQXhFLFNBQVM7WUFDVEQsTUFBTTtRQUNSO1FBQ0EsTUFBTyxLQUFNO1lBQ1gsTUFBTSxFQUFFOEcsSUFBSSxFQUFFMUgsS0FBSyxFQUFFLEdBQUcsTUFBTXVELE9BQU9JLElBQUk7WUFDekMsSUFBSStELE1BQU07Z0JBQ1I7WUFDRjtZQUNBRixvQkFBb0IxRCxPQUFPOUQ7WUFDM0IsSUFBSXdILGlCQUFpQkcsVUFBVSxDQUFDLHNCQUFzQjtnQkFDcEQvQixlQUFlLENBQUMsZ0JBQWdCLEdBQUc0QjtZQUNyQyxPQUFPLElBQUlBLGlCQUFpQkcsVUFBVSxDQUFDLG1CQUFtQjtnQkFDeEQvQixlQUFlLENBQUMsYUFBYSxHQUFHNEI7WUFDbEMsT0FBTztnQkFDTDVCLGVBQWUsQ0FBQyxVQUFVLEdBQUc0QjtZQUMvQjtZQUNBaEIsY0FBYztnQkFBRSxHQUFHWixlQUFlO1lBQUM7WUFDbkMsSUFBSSxDQUFDVyxtQkFBbUIsT0FBTyxLQUFLLElBQUlBLGlCQUFnQixNQUFPLE1BQU07Z0JBQ25FaEQsT0FBT1ksTUFBTTtnQkFDYjtZQUNGO1FBQ0Y7UUFDQSxJQUFJcUQsaUJBQWlCRyxVQUFVLENBQUMsc0JBQXNCO1lBQ3BELE1BQU1DLHFCQUFxQmxGLEtBQUszQyxLQUFLLENBQUN5SCxrQkFBa0JwSCxhQUFhO1lBQ3JFd0YsZUFBZSxDQUFDLGdCQUFnQixHQUFHZ0M7WUFDbkNwQixjQUFjO2dCQUFFLEdBQUdaLGVBQWU7WUFBQztRQUNyQztRQUNBLElBQUk0QixpQkFBaUJHLFVBQVUsQ0FBQyxtQkFBbUI7WUFDakQsTUFBTUUsa0JBQWtCbkYsS0FBSzNDLEtBQUssQ0FBQ3lILGtCQUFrQmxHLFVBQVU7WUFDL0RzRSxlQUFlLENBQUMsYUFBYSxHQUFHaUM7WUFDaENyQixjQUFjO2dCQUFFLEdBQUdaLGVBQWU7WUFBQztRQUNyQztRQUNBLElBQUlYLFVBQVU7WUFDWkEsU0FBU1c7UUFDWDtRQUNBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLGdDQUFnQztBQUNoQyxlQUFla0Msa0JBQWtCLEVBQy9CQyxxQkFBcUJDLG9CQUFvQixFQUN6Q0MsMkJBQTJCLEVBQzNCQyx1QkFBdUIsRUFDdkJDLGlCQUFpQixFQUNqQkMsa0JBQWtCLEVBQ25CO0lBQ0MsTUFBTyxLQUFNO1FBQ1gsTUFBTUMsK0JBQStCLE1BQU1MO1FBQzNDLElBQUksY0FBY0ssOEJBQThCO1lBQzlDLElBQUlDLHVCQUF1QjtZQUMzQixLQUFLLE1BQU0xRCxXQUFXeUQsNkJBQTZCcEMsUUFBUSxDQUFFO2dCQUMzRCxJQUFJLENBQUNyQixRQUFReEUsYUFBYSxLQUFLLEtBQUssS0FBSyxPQUFPd0UsUUFBUXhFLGFBQWEsS0FBSyxRQUFPLEtBQU93RSxDQUFBQSxRQUFRdEQsVUFBVSxLQUFLLEtBQUssS0FBSyxPQUFPc0QsUUFBUXRELFVBQVUsS0FBSyxRQUFPLEdBQUk7b0JBQ2hLO2dCQUNGO2dCQUNBZ0gsdUJBQXVCO2dCQUN2QixJQUFJTCw2QkFBNkI7b0JBQy9CLE1BQU1NLGVBQWUzRCxRQUFReEUsYUFBYTtvQkFDMUMsSUFBSSxPQUFPbUksaUJBQWlCLFVBQVU7d0JBQ3BDQyxRQUFRQyxJQUFJLENBQ1Y7d0JBRUY7b0JBQ0Y7b0JBQ0EsTUFBTUMsdUJBQXVCLE1BQU1ULDRCQUNqQ0csc0JBQ0FHO29CQUVGLElBQUlHLHlCQUF5QixLQUFLLEdBQUc7d0JBQ25DSix1QkFBdUI7d0JBQ3ZCO29CQUNGO29CQUNBSCxrQkFBa0JPO2dCQUNwQjtnQkFDQSxJQUFJUix5QkFBeUI7b0JBQzNCLE1BQU1TLFlBQVkvRCxRQUFRdEQsVUFBVTtvQkFDcEMsSUFBSSxDQUFDZixNQUFNQyxPQUFPLENBQUNtSSxjQUFjQSxVQUFVcEgsSUFBSSxDQUFDLENBQUNxSCxXQUFhLE9BQU9BLGFBQWEsV0FBVzt3QkFDM0ZKLFFBQVFDLElBQUksQ0FDVjt3QkFFRjtvQkFDRjtvQkFDQSxNQUFNSSxtQkFBbUIsTUFBTVgsd0JBQXdCRSxzQkFBc0JPO29CQUM3RSxJQUFJRSxxQkFBcUIsS0FBSyxHQUFHO3dCQUMvQlAsdUJBQXVCO3dCQUN2QjtvQkFDRjtvQkFDQUgsa0JBQWtCVTtnQkFDcEI7WUFDRjtZQUNBLElBQUksQ0FBQ1Asc0JBQXNCO2dCQUN6QjtZQUNGO1FBQ0YsT0FBTztZQUNMLElBQUlRLDRCQUE0QixTQUFTakMsUUFBUTtnQkFDL0MsS0FBSyxNQUFNakMsV0FBV2lDLFNBQVNaLFFBQVEsQ0FBRTtvQkFDdkMsSUFBSXJCLFFBQVF0RCxVQUFVLEtBQUssS0FBSyxHQUFHO3dCQUNqQyxLQUFLLE1BQU1zSCxZQUFZaEUsUUFBUXRELFVBQVUsQ0FBRTs0QkFDekMsSUFBSSxPQUFPc0gsYUFBYSxVQUFVO2dDQUNoQyxJQUFJQSxTQUFTbkgsUUFBUSxDQUFDcEIsU0FBUyxJQUFJLE9BQU91SSxTQUFTbkgsUUFBUSxDQUFDcEIsU0FBUyxLQUFLLFVBQVU7b0NBQ2xGdUksU0FBU25ILFFBQVEsQ0FBQ3BCLFNBQVMsR0FBR3FDLEtBQUtzRSxTQUFTLENBQzFDNEIsU0FBU25ILFFBQVEsQ0FBQ3BCLFNBQVM7Z0NBRS9COzRCQUNGO3dCQUNGO29CQUNGO29CQUNBLElBQUl1RSxRQUFReEUsYUFBYSxLQUFLLEtBQUssR0FBRzt3QkFDcEMsSUFBSSxPQUFPd0UsUUFBUXhFLGFBQWEsS0FBSyxVQUFVOzRCQUM3QyxJQUFJd0UsUUFBUXhFLGFBQWEsQ0FBQ0MsU0FBUyxJQUFJLE9BQU91RSxRQUFReEUsYUFBYSxDQUFDQyxTQUFTLEtBQUssVUFBVTtnQ0FDMUZ1RSxRQUFReEUsYUFBYSxDQUFDQyxTQUFTLEdBQUdxQyxLQUFLc0UsU0FBUyxDQUM5Q3BDLFFBQVF4RSxhQUFhLENBQUNDLFNBQVM7NEJBRW5DO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJMEksMkJBQTJCRDtZQUMvQixNQUFNRSwwQkFBMEJYO1lBQ2hDLElBQUksQ0FBQ1csd0JBQXdCNUksYUFBYSxLQUFLLEtBQUssS0FBSyxPQUFPNEksd0JBQXdCNUksYUFBYSxLQUFLLFFBQU8sS0FBTzRJLENBQUFBLHdCQUF3QjFILFVBQVUsS0FBSyxLQUFLLEtBQUssT0FBTzBILHdCQUF3QjFILFVBQVUsS0FBSyxRQUFPLEdBQUk7Z0JBQ2hPO1lBQ0Y7WUFDQSxJQUFJMkcsNkJBQTZCO2dCQUMvQixNQUFNTSxlQUFlUyx3QkFBd0I1SSxhQUFhO2dCQUMxRCxJQUFJLENBQUUsUUFBT21JLGlCQUFpQixRQUFPLEdBQUk7b0JBQ3ZDQyxRQUFRQyxJQUFJLENBQ1Y7b0JBRUY7Z0JBQ0Y7Z0JBQ0EsTUFBTUMsdUJBQXVCLE1BQU1ULDRCQUE0Qkcsc0JBQXNCRztnQkFDckYsSUFBSUcseUJBQXlCLEtBQUssR0FDaEM7Z0JBQ0ZJLDBCQUEwQko7Z0JBQzFCUCxrQkFBa0JPO1lBQ3BCO1lBQ0EsSUFBSVIseUJBQXlCO2dCQUMzQixNQUFNUyxZQUFZSyx3QkFBd0IxSCxVQUFVO2dCQUNwRCxJQUFJLENBQUUsUUFBT3FILGNBQWMsUUFBTyxHQUFJO29CQUNwQ0gsUUFBUUMsSUFBSSxDQUNWO29CQUVGO2dCQUNGO2dCQUNBLE1BQU1JLG1CQUFtQixNQUFNWCx3QkFBd0JFLHNCQUFzQk87Z0JBQzdFLElBQUlFLHFCQUFxQixLQUFLLEdBQzVCO2dCQUNGQywwQkFBMEJEO2dCQUMxQlYsa0JBQWtCVTtZQUNwQjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLG9CQUFvQjtBQUNwQixJQUFJZCxzQkFBc0IsT0FBTzVCLEtBQUs4QyxhQUFhQyxRQUFRQyxrQkFBa0JDLGNBQWNDLGtCQUFrQkMsYUFBYXZFLG9CQUFvQkcsWUFBWUQsVUFBVXlCLFlBQVk2QztJQUM5SyxJQUFJM0MsSUFBSTRDO0lBQ1IsTUFBTUMsbUJBQW1CSCxZQUFZN0QsT0FBTztJQUM1Q3lELE9BQU9ELFlBQVloRCxRQUFRLEVBQUU7SUFDN0IsTUFBTXlELDZCQUE2QkgseUJBQXlCTixZQUFZaEQsUUFBUSxHQUFHZ0QsWUFBWWhELFFBQVEsQ0FBQ2xFLEdBQUcsQ0FDekcsQ0FBQyxFQUFFbkIsSUFBSSxFQUFFQyxPQUFPLEVBQUVmLElBQUksRUFBRU0sYUFBYSxFQUFFa0IsVUFBVSxFQUFFcUksWUFBWSxFQUFFLEdBQU07WUFDckUvSTtZQUNBQztZQUNBOEk7WUFDQSxHQUFHN0osU0FBUyxLQUFLLEtBQUs7Z0JBQUVBO1lBQUssQ0FBQztZQUM5QixHQUFHTSxrQkFBa0IsS0FBSyxLQUFLO2dCQUM3QkE7WUFDRixDQUFDO1lBQ0QsR0FBR2tCLGVBQWUsS0FBSyxLQUFLO2dCQUMxQkE7WUFDRixDQUFDO1FBQ0g7SUFFRixJQUFJLE9BQU82RSxRQUFRLFVBQVU7UUFDM0IsTUFBTXNCLFVBQVV2QztRQUNoQixNQUFNRyxZQUFZLGFBQWEsR0FBRyxJQUFJRDtRQUN0QyxJQUFJUSxrQkFBa0I7WUFDcEJqRixJQUFJOEc7WUFDSnBDO1lBQ0F4RSxTQUFTO1lBQ1RELE1BQU07UUFDUjtRQUNBLGVBQWVnSixRQUFRQyxPQUFPO1lBQzVCLE1BQU0sRUFBRWhKLE9BQU8sRUFBRWlKLEVBQUUsRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTUY7WUFDcENqRSxlQUFlLENBQUMsVUFBVSxHQUFHL0U7WUFDN0IrRSxlQUFlLENBQUMsS0FBSyxHQUFHLE1BQU1rRTtZQUM5QlosT0FBTzttQkFBSUQsWUFBWWhELFFBQVE7Z0JBQUU7b0JBQUUsR0FBR0wsZUFBZTtnQkFBQzthQUFFLEVBQUU7WUFDMUQsSUFBSW1FLE1BQU07Z0JBQ1IsTUFBTUgsUUFBUUc7WUFDaEI7UUFDRjtRQUNBLElBQUk7WUFDRixNQUFNRixVQUFVMUQsSUFBSTtnQkFDbEJGLFVBQVV5RDtnQkFDVm5FLE1BQU0wRCxZQUFZMUQsSUFBSTtZQUN4QjtZQUNBLE1BQU1xRSxRQUFRQztRQUNoQixFQUFFLE9BQU9HLEdBQUc7WUFDVmQsT0FBT08sa0JBQWtCO1lBQ3pCLE1BQU1PO1FBQ1I7UUFDQSxJQUFJL0UsVUFBVTtZQUNaQSxTQUFTVztRQUNYO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE9BQU8sTUFBTU0sWUFBWTtRQUN2QkM7UUFDQUYsVUFBVXlEO1FBQ1Z0RCxNQUFNO1lBQ0piLE1BQU0wRCxZQUFZMUQsSUFBSTtZQUN0QixHQUFHOEQsaUJBQWlCNUQsT0FBTyxDQUFDVyxJQUFJO1lBQ2hDLEdBQUcsQ0FBQ1EsS0FBS3FDLFlBQVlnQixPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlyRCxHQUFHUixJQUFJO1lBQ3hELEdBQUc2QyxZQUFZaUIsU0FBUyxLQUFLLEtBQUssS0FBSztnQkFDckNBLFdBQVdqQixZQUFZaUIsU0FBUztZQUNsQyxDQUFDO1lBQ0QsR0FBR2pCLFlBQVk3SSxhQUFhLEtBQUssS0FBSyxLQUFLO2dCQUN6Q0EsZUFBZTZJLFlBQVk3SSxhQUFhO1lBQzFDLENBQUM7WUFDRCxHQUFHNkksWUFBWWtCLEtBQUssS0FBSyxLQUFLLEtBQUs7Z0JBQ2pDQSxPQUFPbEIsWUFBWWtCLEtBQUs7WUFDMUIsQ0FBQztZQUNELEdBQUdsQixZQUFZbUIsV0FBVyxLQUFLLEtBQUssS0FBSztnQkFDdkNBLGFBQWFuQixZQUFZbUIsV0FBVztZQUN0QyxDQUFDO1FBQ0g7UUFDQS9ELGFBQWFnRCxpQkFBaUI1RCxPQUFPLENBQUNZLFdBQVc7UUFDakRDLFNBQVM7WUFDUCxHQUFHK0MsaUJBQWlCNUQsT0FBTyxDQUFDYSxPQUFPO1lBQ25DLEdBQUcsQ0FBQ2tELEtBQUtQLFlBQVlnQixPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlULEdBQUdsRCxPQUFPO1FBQzdEO1FBQ0FDLGlCQUFpQixJQUFNeEIsbUJBQW1CVSxPQUFPO1FBQ2pEZSxlQUFjNUIsT0FBTztZQUNuQnNFLE9BQU87bUJBQUlELFlBQVloRCxRQUFRO2dCQUFFckI7YUFBUSxFQUFFO1FBQzdDO1FBQ0E2QjtZQUNFeUMsT0FBT08sa0JBQWtCO1FBQzNCO1FBQ0EvQztRQUNBQyxVQUFTWCxNQUFNLEVBQUVULElBQUk7WUFDbkIyRCxPQUFPO21CQUFJRCxZQUFZaEQsUUFBUTttQkFBS0Q7YUFBTyxFQUFFO1lBQzdDbUQsaUJBQWlCO21CQUFJQyxnQkFBZ0IsRUFBRTttQkFBSzdELFFBQVEsRUFBRTthQUFDLEVBQUU7UUFDM0Q7UUFDQU47UUFDQUM7SUFDRjtBQUNGO0FBQ0EsU0FBU21GLFFBQVEsRUFDZmxFLE1BQU0sV0FBVyxFQUNqQnhGLEVBQUUsRUFDRjJKLGVBQWUsRUFDZkMsZUFBZSxFQUFFLEVBQ2pCaEIsc0JBQXNCLEVBQ3RCdEIsMkJBQTJCLEVBQzNCQyx1QkFBdUIsRUFDdkJ4QixVQUFVLEVBQ1Z6QixRQUFRLEVBQ1J1RixPQUFPLEVBQ1BuRSxXQUFXLEVBQ1hDLE9BQU8sRUFDUEYsSUFBSSxFQUNKbEIsYUFBYWIsTUFBTSxFQUNwQixHQUFHLENBQUMsQ0FBQztJQUNKLE1BQU1vRyxTQUFTakwsNENBQUtBO0lBQ3BCLE1BQU1rTCxRQUFRL0osTUFBTSxPQUFPQSxLQUFLOEo7SUFDaEMsTUFBTUUsVUFBVSxPQUFPeEUsUUFBUSxXQUFXO1FBQUNBO1FBQUt1RTtLQUFNLEdBQUdBO0lBQ3pELE1BQU0sQ0FBQ0Usd0JBQXdCLEdBQUdsTCwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzdDLE1BQU0sRUFBRTZGLE1BQU1VLFFBQVEsRUFBRWlELE1BQU0sRUFBRSxHQUFHdkosK0NBQU1BLENBQ3ZDO1FBQUNnTDtRQUFTO0tBQVcsRUFDckIsTUFDQTtRQUFFRSxjQUFjUCxtQkFBbUIsT0FBT0Esa0JBQWtCTTtJQUF3QjtJQUV0RixNQUFNLEVBQUVyRixNQUFNdUYsWUFBWSxLQUFLLEVBQUU1QixRQUFRNkIsYUFBYSxFQUFFLEdBQUdwTCwrQ0FBTUEsQ0FDL0Q7UUFBQ2dMO1FBQVM7S0FBVSxFQUNwQjtJQUVGLE1BQU0sRUFBRXBGLE1BQU15RixVQUFVLEVBQUU5QixRQUFRQyxnQkFBZ0IsRUFBRSxHQUFHeEosK0NBQU1BLENBQUM7UUFBQ2dMO1FBQVM7S0FBYSxFQUFFO0lBQ3ZGLE1BQU0sRUFBRXBGLE1BQU0wRixRQUFRLEtBQUssQ0FBQyxFQUFFL0IsUUFBUWdDLFFBQVEsRUFBRSxHQUFHdkwsK0NBQU1BLENBQUM7UUFBQ2dMO1FBQVM7S0FBUSxFQUFFO0lBQzlFLE1BQU1yQixjQUFjN0osNkNBQU1BLENBQUN3RyxZQUFZLEVBQUU7SUFDekMxRyxnREFBU0EsQ0FBQztRQUNSK0osWUFBWTdELE9BQU8sR0FBR1EsWUFBWSxFQUFFO0lBQ3RDLEdBQUc7UUFBQ0E7S0FBUztJQUNiLE1BQU1sQixxQkFBcUJ0Riw2Q0FBTUEsQ0FBQztJQUNsQyxNQUFNNEosbUJBQW1CNUosNkNBQU1BLENBQUM7UUFDOUI0RztRQUNBQztRQUNBRjtJQUNGO0lBQ0E3RyxnREFBU0EsQ0FBQztRQUNSOEosaUJBQWlCNUQsT0FBTyxHQUFHO1lBQ3pCWTtZQUNBQztZQUNBRjtRQUNGO0lBQ0YsR0FBRztRQUFDQztRQUFhQztRQUFTRjtLQUFLO0lBQy9CLE1BQU0rRSxpQkFBaUI3TCxrREFBV0EsQ0FDaEMsT0FBTzJKO1FBQ0wsSUFBSTtZQUNGOEIsY0FBYztZQUNkRyxTQUFTLEtBQUs7WUFDZCxNQUFNM0Usa0JBQWtCLElBQUk2RTtZQUM1QnJHLG1CQUFtQlUsT0FBTyxHQUFHYztZQUM3QixNQUFNdUIsa0JBQWtCO2dCQUN0QkMscUJBQXFCLElBQU1BLG9CQUN6QjVCLEtBQ0E4QyxhQUNBQyxRQUNBQyxrQkFDQTZCLFlBQ0EzQixrQkFDQUMsYUFDQXZFLG9CQUNBRyxZQUNBRCxVQUNBeUIsWUFDQTZDO2dCQUVGdEI7Z0JBQ0FDO2dCQUNBQyxtQkFBbUIsQ0FBQ2tEO29CQUNsQnBDLGNBQWNvQztnQkFDaEI7Z0JBQ0FqRCxvQkFBb0IsSUFBTWtCLFlBQVk3RCxPQUFPO1lBQy9DO1lBQ0FWLG1CQUFtQlUsT0FBTyxHQUFHO1FBQy9CLEVBQUUsT0FBTzBCLEtBQUs7WUFDWixJQUFJQSxJQUFJckgsSUFBSSxLQUFLLGNBQWM7Z0JBQzdCaUYsbUJBQW1CVSxPQUFPLEdBQUc7Z0JBQzdCLE9BQU87WUFDVDtZQUNBLElBQUkrRSxXQUFXckQsZUFBZWxILE9BQU87Z0JBQ25DdUssUUFBUXJEO1lBQ1Y7WUFDQStELFNBQVMvRDtRQUNYLFNBQVU7WUFDUjRELGNBQWM7UUFDaEI7SUFDRixHQUNBO1FBQ0U3QjtRQUNBNkI7UUFDQTVFO1FBQ0FrRDtRQUNBM0M7UUFDQXpCO1FBQ0F1RjtRQUNBVTtRQUNBL0I7UUFDQTZCO1FBQ0F6QjtRQUNBdEI7UUFDQUM7UUFDQW9CO1FBQ0F2RTtRQUNBRztLQUNEO0lBRUgsTUFBTW9HLFNBQVNoTSxrREFBV0EsQ0FDeEIsT0FBT3NGLFNBQVMsRUFDZHFGLE9BQU8sRUFDUEMsU0FBUyxFQUNUOUosYUFBYSxFQUNiK0osS0FBSyxFQUNMQyxXQUFXLEVBQ1g3RSxJQUFJLEVBQ0wsR0FBRyxDQUFDLENBQUM7UUFDSixJQUFJLENBQUNYLFFBQVFqRSxFQUFFLEVBQUU7WUFDZmlFLFFBQVFqRSxFQUFFLEdBQUd1RTtRQUNmO1FBQ0EsTUFBTStELGNBQWM7WUFDbEJoRCxVQUFVcUQsWUFBWTdELE9BQU8sQ0FBQzhGLE1BQU0sQ0FBQzNHO1lBQ3JDcUY7WUFDQTFFO1lBQ0EsR0FBRzJFLGNBQWMsS0FBSyxLQUFLO2dCQUFFQTtZQUFVLENBQUM7WUFDeEMsR0FBRzlKLGtCQUFrQixLQUFLLEtBQUs7Z0JBQUVBO1lBQWMsQ0FBQztZQUNoRCxHQUFHK0osVUFBVSxLQUFLLEtBQUs7Z0JBQUVBO1lBQU0sQ0FBQztZQUNoQyxHQUFHQyxnQkFBZ0IsS0FBSyxLQUFLO2dCQUFFQTtZQUFZLENBQUM7UUFDOUM7UUFDQSxPQUFPZSxlQUFlbEM7SUFDeEIsR0FDQTtRQUFDa0M7UUFBZ0JqRztLQUFXO0lBRTlCLE1BQU1zRyxTQUFTbE0sa0RBQVdBLENBQ3hCLE9BQU8sRUFDTDJLLE9BQU8sRUFDUEMsU0FBUyxFQUNUOUosYUFBYSxFQUNiK0osS0FBSyxFQUNMQyxXQUFXLEVBQ1osR0FBRyxDQUFDLENBQUM7UUFDSixJQUFJZCxZQUFZN0QsT0FBTyxDQUFDcEMsTUFBTSxLQUFLLEdBQ2pDLE9BQU87UUFDVCxNQUFNb0ksY0FBY25DLFlBQVk3RCxPQUFPLENBQUM2RCxZQUFZN0QsT0FBTyxDQUFDcEMsTUFBTSxHQUFHLEVBQUU7UUFDdkUsSUFBSW9JLFlBQVk3SyxJQUFJLEtBQUssYUFBYTtZQUNwQyxNQUFNOEssZUFBZTtnQkFDbkJ6RixVQUFVcUQsWUFBWTdELE9BQU8sQ0FBQ25ELEtBQUssQ0FBQyxHQUFHLENBQUM7Z0JBQ3hDMkg7Z0JBQ0EsR0FBR0MsY0FBYyxLQUFLLEtBQUs7b0JBQUVBO2dCQUFVLENBQUM7Z0JBQ3hDLEdBQUc5SixrQkFBa0IsS0FBSyxLQUFLO29CQUFFQTtnQkFBYyxDQUFDO2dCQUNoRCxHQUFHK0osVUFBVSxLQUFLLEtBQUs7b0JBQUVBO2dCQUFNLENBQUM7Z0JBQ2hDLEdBQUdDLGdCQUFnQixLQUFLLEtBQUs7b0JBQUVBO2dCQUFZLENBQUM7WUFDOUM7WUFDQSxPQUFPZSxlQUFlTztRQUN4QjtRQUNBLE1BQU16QyxjQUFjO1lBQ2xCaEQsVUFBVXFELFlBQVk3RCxPQUFPO1lBQzdCd0U7WUFDQSxHQUFHQyxjQUFjLEtBQUssS0FBSztnQkFBRUE7WUFBVSxDQUFDO1lBQ3hDLEdBQUc5SixrQkFBa0IsS0FBSyxLQUFLO2dCQUFFQTtZQUFjLENBQUM7WUFDaEQsR0FBRytKLFVBQVUsS0FBSyxLQUFLO2dCQUFFQTtZQUFNLENBQUM7WUFDaEMsR0FBR0MsZ0JBQWdCLEtBQUssS0FBSztnQkFBRUE7WUFBWSxDQUFDO1FBQzlDO1FBQ0EsT0FBT2UsZUFBZWxDO0lBQ3hCLEdBQ0E7UUFBQ2tDO0tBQWU7SUFFbEIsTUFBTVEsT0FBT3JNLGtEQUFXQSxDQUFDO1FBQ3ZCLElBQUl5RixtQkFBbUJVLE9BQU8sRUFBRTtZQUM5QlYsbUJBQW1CVSxPQUFPLENBQUNtRyxLQUFLO1lBQ2hDN0csbUJBQW1CVSxPQUFPLEdBQUc7UUFDL0I7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNb0csY0FBY3ZNLGtEQUFXQSxDQUM3QixDQUFDd007UUFDQzVDLE9BQU80QyxXQUFXO1FBQ2xCeEMsWUFBWTdELE9BQU8sR0FBR3FHO0lBQ3hCLEdBQ0E7UUFBQzVDO0tBQU87SUFFVixNQUFNLENBQUM2QyxPQUFPQyxTQUFTLEdBQUd0TSwrQ0FBUUEsQ0FBQzZLO0lBQ25DLE1BQU0wQixlQUFlM00sa0RBQVdBLENBQzlCLENBQUMwSyxHQUFHQyxVQUFVLENBQUMsQ0FBQyxFQUFFaUM7UUFDaEIsSUFBSUEsVUFBVTtZQUNaN0MsaUJBQWlCNUQsT0FBTyxHQUFHO2dCQUN6QixHQUFHNEQsaUJBQWlCNUQsT0FBTztnQkFDM0IsR0FBR3lHLFFBQVE7WUFDYjtRQUNGO1FBQ0FsQyxFQUFFbUMsY0FBYztRQUNoQixJQUFJLENBQUNKLE9BQ0g7UUFDRlQsT0FDRTtZQUNFekssU0FBU2tMO1lBQ1RuTCxNQUFNO1lBQ055RSxXQUFXLGFBQWEsR0FBRyxJQUFJRDtRQUNqQyxHQUNBNkU7UUFFRitCLFNBQVM7SUFDWCxHQUNBO1FBQUNEO1FBQU9UO0tBQU87SUFFakIsTUFBTWMsb0JBQW9CLENBQUNwQztRQUN6QmdDLFNBQVNoQyxFQUFFcUMsTUFBTSxDQUFDck0sS0FBSztJQUN6QjtJQUNBLE9BQU87UUFDTGlHLFVBQVVBLFlBQVksRUFBRTtRQUN4QmdGO1FBQ0FLO1FBQ0FFO1FBQ0FHO1FBQ0FFO1FBQ0FFO1FBQ0FDO1FBQ0FJO1FBQ0FIO1FBQ0FuQjtRQUNBdkYsTUFBTXlGO0lBQ1I7QUFDRjtBQUVBLDBCQUEwQjtBQUM4RztBQUM5RztBQUUxQixnQ0FBZ0M7QUFDaEMsZUFBZTRCLGtCQUFrQixFQUMvQnpHLEdBQUcsRUFDSDBHLE1BQU0sRUFDTnhHLFdBQVcsRUFDWEMsT0FBTyxFQUNQRixJQUFJLEVBQ0owRyxhQUFhLEVBQ2JDLFVBQVUsRUFDVjdCLFFBQVEsRUFDUjhCLGtCQUFrQixFQUNsQnRHLFVBQVUsRUFDVnpCLFFBQVEsRUFDUnVGLE9BQU8sRUFDUHlDLE1BQU0sRUFDUDtJQUNDLElBQUk7UUFDRkYsV0FBVztRQUNYN0IsU0FBUyxLQUFLO1FBQ2QsTUFBTTNFLGtCQUFrQixJQUFJNkU7UUFDNUI0QixtQkFBbUJ6RztRQUNuQnVHLGNBQWM7UUFDZCxNQUFNSSxNQUFNLE1BQU1wRyxNQUFNWCxLQUFLO1lBQzNCWSxRQUFRO1lBQ1JYLE1BQU0xRCxLQUFLc0UsU0FBUyxDQUFDO2dCQUNuQjZGO2dCQUNBLEdBQUd6RyxJQUFJO1lBQ1Q7WUFDQUM7WUFDQUMsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCLEdBQUdBLE9BQU87WUFDWjtZQUNBVyxRQUFRVixnQkFBZ0JVLE1BQU07UUFDaEMsR0FBR0MsS0FBSyxDQUFDLENBQUNDO1lBQ1IsTUFBTUE7UUFDUjtRQUNBLElBQUlULFlBQVk7WUFDZCxJQUFJO2dCQUNGLE1BQU1BLFdBQVd3RztZQUNuQixFQUFFLE9BQU8vRixLQUFLO2dCQUNaLE1BQU1BO1lBQ1I7UUFDRjtRQUNBLElBQUksQ0FBQytGLElBQUk5RixFQUFFLEVBQUU7WUFDWCxNQUFNLElBQUluSCxNQUNSLE1BQU1pTixJQUFJbE0sSUFBSSxNQUFNO1FBRXhCO1FBQ0EsSUFBSSxDQUFDa00sSUFBSTlHLElBQUksRUFBRTtZQUNiLE1BQU0sSUFBSW5HLE1BQU07UUFDbEI7UUFDQSxJQUFJa04sU0FBUztRQUNiLE1BQU01SixTQUFTMkosSUFBSTlHLElBQUksQ0FBQ2lCLFNBQVM7UUFDakMsTUFBTUMsZ0JBQWdCNEYsSUFBSTVHLE9BQU8sQ0FBQ2lCLEdBQUcsQ0FBQzdDLG9CQUFvQjtRQUMxRCxJQUFJNEMsZUFBZTtZQUNqQixXQUFXLE1BQU0sRUFBRXBILElBQUksRUFBRUYsS0FBSyxFQUFFLElBQUlzRCxlQUFlQyxRQUFRO2dCQUN6REMsV0FBVyxJQUFNK0Msb0JBQW9CO1lBQ3ZDLEdBQUk7Z0JBQ0YsT0FBUXJHO29CQUNOLEtBQUs7d0JBQVE7NEJBQ1hpTixVQUFVbk47NEJBQ1Y4TSxjQUFjSzs0QkFDZDt3QkFDRjtvQkFDQSxLQUFLO3dCQUFROzRCQUNYRixVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPak47NEJBQ2pDO3dCQUNGO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsTUFBTXlELFVBQVVhO1lBQ2hCLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVvRCxJQUFJLEVBQUUxSCxLQUFLLEVBQUUsR0FBRyxNQUFNdUQsT0FBT0ksSUFBSTtnQkFDekMsSUFBSStELE1BQU07b0JBQ1I7Z0JBQ0Y7Z0JBQ0F5RixVQUFVMUosUUFBUXpEO2dCQUNsQjhNLGNBQWNLO2dCQUNkLElBQUk1RyxvQkFBb0IsTUFBTTtvQkFDNUJoRCxPQUFPWSxNQUFNO29CQUNiO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLElBQUljLFVBQVU7WUFDWkEsU0FBUzRILFFBQVFNO1FBQ25CO1FBQ0FILG1CQUFtQjtRQUNuQixPQUFPRztJQUNULEVBQUUsT0FBT2hHLEtBQUs7UUFDWixJQUFJQSxJQUFJckgsSUFBSSxLQUFLLGNBQWM7WUFDN0JrTixtQkFBbUI7WUFDbkIsT0FBTztRQUNUO1FBQ0EsSUFBSTdGLGVBQWVsSCxPQUFPO1lBQ3hCLElBQUl1SyxTQUFTO2dCQUNYQSxRQUFRckQ7WUFDVjtRQUNGO1FBQ0ErRCxTQUFTL0Q7SUFDWCxTQUFVO1FBQ1I0RixXQUFXO0lBQ2I7QUFDRjtBQUVBLDBCQUEwQjtBQUMxQixTQUFTSyxjQUFjLEVBQ3JCakgsTUFBTSxpQkFBaUIsRUFDdkJ4RixFQUFFLEVBQ0YwTSxvQkFBb0IsRUFBRSxFQUN0QjlDLGVBQWUsRUFBRSxFQUNqQmxFLFdBQVcsRUFDWEMsT0FBTyxFQUNQRixJQUFJLEVBQ0pNLFVBQVUsRUFDVnpCLFFBQVEsRUFDUnVGLE9BQU8sRUFDUixHQUFHLENBQUMsQ0FBQztJQUNKLE1BQU1DLFNBQVMrQiw0Q0FBTUE7SUFDckIsTUFBTWMsZUFBZTNNLE1BQU04SjtJQUMzQixNQUFNLEVBQUVsRixJQUFJLEVBQUUyRCxNQUFNLEVBQUUsR0FBR3lELCtDQUFPQSxDQUFDO1FBQUN4RztRQUFLbUg7S0FBYSxFQUFFLE1BQU07UUFDMUR6QyxjQUFjd0M7SUFDaEI7SUFDQSxNQUFNLEVBQUU5SCxNQUFNdUYsWUFBWSxLQUFLLEVBQUU1QixRQUFRNkIsYUFBYSxFQUFFLEdBQUc0QiwrQ0FBT0EsQ0FDaEU7UUFBQ1c7UUFBYztLQUFVLEVBQ3pCO0lBRUYsTUFBTSxFQUFFL0gsTUFBTXlGLFVBQVUsRUFBRTlCLFFBQVFDLGdCQUFnQixFQUFFLEdBQUd3RCwrQ0FBT0EsQ0FBQztRQUFDVztRQUFjO0tBQWEsRUFBRTtJQUM3RixNQUFNLENBQUNyQyxPQUFPQyxTQUFTLEdBQUd3QiwrQ0FBU0EsQ0FBQyxLQUFLO0lBQ3pDLE1BQU1hLGFBQWFoSTtJQUNuQixNQUFNLENBQUNnQixpQkFBaUJ5RyxtQkFBbUIsR0FBR04sK0NBQVNBLENBQUM7SUFDeEQsTUFBTXJELG1CQUFtQm9ELDZDQUFPQSxDQUFDO1FBQy9CcEc7UUFDQUM7UUFDQUY7SUFDRjtJQUNBbUcsZ0RBQVVBLENBQUM7UUFDVGxELGlCQUFpQjVELE9BQU8sR0FBRztZQUN6Qlk7WUFDQUM7WUFDQUY7UUFDRjtJQUNGLEdBQUc7UUFBQ0M7UUFBYUM7UUFBU0Y7S0FBSztJQUMvQixNQUFNK0UsaUJBQWlCbUIsa0RBQVlBLENBQ2pDLE9BQU9PLFFBQVE1QyxVQUFZMkMsa0JBQWtCO1lBQzNDekc7WUFDQTBHO1lBQ0F4RyxhQUFhZ0QsaUJBQWlCNUQsT0FBTyxDQUFDWSxXQUFXO1lBQ2pEQyxTQUFTO2dCQUFFLEdBQUcrQyxpQkFBaUI1RCxPQUFPLENBQUNhLE9BQU87Z0JBQUUsR0FBRzJELFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVEzRCxPQUFPO1lBQUM7WUFDOUZGLE1BQU07Z0JBQ0osR0FBR2lELGlCQUFpQjVELE9BQU8sQ0FBQ1csSUFBSTtnQkFDaEMsR0FBRzZELFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVE3RCxJQUFJO1lBQzVDO1lBQ0EwRyxlQUFlLENBQUNVLGNBQWdCdEUsT0FBT3NFLGFBQWE7WUFDcERULFlBQVloQztZQUNaRztZQUNBOEI7WUFDQXRHO1lBQ0F6QjtZQUNBdUY7WUFDQXlDLFFBQVEsQ0FBQ1E7Z0JBQ1B0RSxpQkFBaUI7dUJBQUk2QixjQUFjLEVBQUU7dUJBQUt5QyxTQUFTLEVBQUU7aUJBQUMsRUFBRTtZQUMxRDtRQUNGLElBQ0E7UUFDRXZFO1FBQ0E2QjtRQUNBNUU7UUFDQWtEO1FBQ0EyRDtRQUNBdEc7UUFDQXpCO1FBQ0F1RjtRQUNBVTtRQUNBRjtRQUNBN0I7S0FDRDtJQUVILE1BQU13QyxPQUFPVyxrREFBWUEsQ0FBQztRQUN4QixJQUFJL0YsaUJBQWlCO1lBQ25CQSxnQkFBZ0JxRixLQUFLO1lBQ3JCb0IsbUJBQW1CO1FBQ3JCO0lBQ0YsR0FBRztRQUFDekc7S0FBZ0I7SUFDcEIsTUFBTXVHLGdCQUFnQlIsa0RBQVlBLENBQ2hDLENBQUNrQjtRQUNDdEUsT0FBT3NFLGFBQWE7SUFDdEIsR0FDQTtRQUFDdEU7S0FBTztJQUVWLE1BQU13RSxXQUFXcEIsa0RBQVlBLENBQzNCLE9BQU9PLFFBQVE1QztRQUNiLE9BQU9rQixlQUFlMEIsUUFBUTVDO0lBQ2hDLEdBQ0E7UUFBQ2tCO0tBQWU7SUFFbEIsTUFBTSxDQUFDWSxPQUFPQyxTQUFTLEdBQUdVLCtDQUFTQSxDQUFDbkM7SUFDcEMsTUFBTTBCLGVBQWVLLGtEQUFZQSxDQUMvQixDQUFDdEM7UUFDQ0EsRUFBRW1DLGNBQWM7UUFDaEIsSUFBSSxDQUFDSixPQUNIO1FBQ0YsT0FBTzJCLFNBQVMzQjtJQUNsQixHQUNBO1FBQUNBO1FBQU8yQjtLQUFTO0lBRW5CLE1BQU10QixvQkFBb0IsQ0FBQ3BDO1FBQ3pCZ0MsU0FBU2hDLEVBQUVxQyxNQUFNLENBQUNyTSxLQUFLO0lBQ3pCO0lBQ0EsT0FBTztRQUNMdU47UUFDQUc7UUFDQXpDO1FBQ0E2QjtRQUNBbkI7UUFDQUk7UUFDQUM7UUFDQUk7UUFDQUg7UUFDQW5CO1FBQ0F2RixNQUFNeUY7SUFDUjtBQUNGO0FBRUEseUJBQXlCO0FBQ3FCO0FBQzlDLFNBQVM0QywwQkFBMEIsRUFDakN6SCxHQUFHLEVBQ0hqRixVQUFVMk0sYUFBYSxFQUN2QnhILFdBQVcsRUFDWEMsT0FBTyxFQUNQRixJQUFJLEVBQ0pvRSxPQUFPLEVBQ1I7SUFDQyxNQUFNLENBQUN2RSxVQUFVNEYsWUFBWSxHQUFHOEIsK0NBQVNBLENBQUMsRUFBRTtJQUM1QyxNQUFNLENBQUM1QixPQUFPQyxTQUFTLEdBQUcyQiwrQ0FBU0EsQ0FBQztJQUNwQyxNQUFNLENBQUN6TSxVQUFVNE0sWUFBWSxHQUFHSCwrQ0FBU0EsQ0FBQyxLQUFLO0lBQy9DLE1BQU0sQ0FBQ0ksUUFBUUMsVUFBVSxHQUFHTCwrQ0FBU0EsQ0FBQztJQUN0QyxNQUFNLENBQUMxQyxPQUFPQyxTQUFTLEdBQUd5QywrQ0FBU0EsQ0FBQyxLQUFLO0lBQ3pDLE1BQU12QixvQkFBb0IsQ0FBQzZCO1FBQ3pCakMsU0FBU2lDLE1BQU01QixNQUFNLENBQUNyTSxLQUFLO0lBQzdCO0lBQ0EsTUFBTWtPLGdCQUFnQixPQUFPRCxPQUFPRTtRQUNsQyxJQUFJdkgsSUFBSTRDO1FBQ1A1QyxDQUFBQSxLQUFLcUgsU0FBUyxPQUFPLEtBQUssSUFBSUEsTUFBTTlCLGNBQWMsS0FBSyxPQUFPLEtBQUssSUFBSXZGLEdBQUd3SCxJQUFJLENBQUNIO1FBQ2hGLElBQUlsQyxVQUFVLElBQUk7WUFDaEI7UUFDRjtRQUNBaUMsVUFBVTtRQUNWbkMsWUFBWSxDQUFDQyxZQUFjO21CQUN0QkE7Z0JBQ0g7b0JBQUVuTCxJQUFJO29CQUFJQyxNQUFNO29CQUFRQyxTQUFTa0w7Z0JBQU07YUFDeEM7UUFDREMsU0FBUztRQUNULE1BQU1tQixTQUFTLE1BQU1yRyxNQUFNWCxLQUFLO1lBQzlCWSxRQUFRO1lBQ1JWO1lBQ0FDLFNBQVM7Z0JBQUUsZ0JBQWdCO2dCQUFvQixHQUFHQSxPQUFPO1lBQUM7WUFDMURGLE1BQU0xRCxLQUFLc0UsU0FBUyxDQUFDO2dCQUNuQixHQUFHWixJQUFJO2dCQUNQLG9EQUFvRDtnQkFDcERsRixVQUFVLENBQUNzSSxLQUFLcUUsaUJBQWlCLE9BQU9BLGdCQUFnQjNNLFFBQU8sS0FBTSxPQUFPc0ksS0FBSztnQkFDakY1RSxTQUFTbUg7Z0JBQ1QseUJBQXlCO2dCQUN6QnhHLE1BQU00SSxrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWU1SSxJQUFJO1lBQzdEO1FBQ0Y7UUFDQSxJQUFJNEgsT0FBTy9HLElBQUksSUFBSSxNQUFNO1lBQ3ZCLE1BQU0sSUFBSW5HLE1BQU07UUFDbEI7UUFDQSxJQUFJO1lBQ0YsV0FBVyxNQUFNLEVBQUVDLElBQUksRUFBRUYsS0FBSyxFQUFFLElBQUlzRCxlQUNsQzZKLE9BQU8vRyxJQUFJLENBQUNpQixTQUFTLElBQ3BCO2dCQUNELE9BQVFuSDtvQkFDTixLQUFLO3dCQUFxQjs0QkFDeEIyTCxZQUFZLENBQUNDLFlBQWM7dUNBQ3RCQTtvQ0FDSDt3Q0FDRW5MLElBQUlYLE1BQU1XLEVBQUU7d0NBQ1pDLE1BQU1aLE1BQU1ZLElBQUk7d0NBQ2hCQyxTQUFTYixNQUFNYSxPQUFPLENBQUMsRUFBRSxDQUFDRyxJQUFJLENBQUNoQixLQUFLO29DQUN0QztpQ0FDRDs0QkFDRDt3QkFDRjtvQkFDQSxLQUFLO3dCQUFnQjs0QkFDbkI2TCxZQUFZLENBQUNDO2dDQUNYLElBQUl1QztnQ0FDSixPQUFPO3VDQUNGdkM7b0NBQ0g7d0NBQ0VuTCxJQUFJLENBQUMwTixNQUFNck8sTUFBTVcsRUFBRSxLQUFLLE9BQU8wTixNQUFNO3dDQUNyQ3pOLE1BQU07d0NBQ05DLFNBQVM7d0NBQ1QwRSxNQUFNdkYsTUFBTXVGLElBQUk7b0NBQ2xCO2lDQUNEOzRCQUNIOzRCQUNBO3dCQUNGO29CQUNBLEtBQUs7d0JBQTBCOzRCQUM3QnVJLFlBQVk5TixNQUFNa0IsUUFBUTs0QkFDMUIySyxZQUFZLENBQUNDO2dDQUNYLE1BQU1MLGNBQWNLLFNBQVMsQ0FBQ0EsVUFBVXpJLE1BQU0sR0FBRyxFQUFFO2dDQUNuRG9JLFlBQVk5SyxFQUFFLEdBQUdYLE1BQU1tQixTQUFTO2dDQUNoQyxPQUFPO3VDQUFJMkssVUFBVXhKLEtBQUssQ0FBQyxHQUFHd0osVUFBVXpJLE1BQU0sR0FBRztvQ0FBSW9JO2lDQUFZOzRCQUNuRTs0QkFDQTt3QkFDRjtvQkFDQSxLQUFLO3dCQUFTOzRCQUNaLE1BQU02QyxXQUFXLElBQUlyTyxNQUFNRDs0QkFDM0JrTCxTQUFTb0Q7NEJBQ1Q7d0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBT0MsUUFBUTtZQUNmLElBQUkvRCxXQUFXK0Qsa0JBQWtCdE8sT0FBTztnQkFDdEN1SyxRQUFRK0Q7WUFDVjtZQUNBckQsU0FBU3FEO1FBQ1g7UUFDQVAsVUFBVTtJQUNaO0lBQ0EsT0FBTztRQUNML0g7UUFDQS9FO1FBQ0E2SztRQUNBQztRQUNBSTtRQUNBOEI7UUFDQUg7UUFDQTlDO0lBQ0Y7QUFDRjtBQUtFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdC1zYW1wbGUvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanM/MmJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKCh0YykgPT4ge1xuICAgICAgdGMgPT0gbnVsbCB8fCB0eXBlb2YgdGMgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy5pZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidHlwZVwiIGluIHRjKSB8fCB0eXBlb2YgdGMudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiZnVuY3Rpb25cIiBpbiB0YykgfHwgdGMuZnVuY3Rpb24gPT0gbnVsbCB8fCB0eXBlb2YgdGMuZnVuY3Rpb24gIT09IFwib2JqZWN0XCIgfHwgIShcImFyZ3VtZW50c1wiIGluIHRjLmZ1bmN0aW9uKSB8fCB0eXBlb2YgdGMuZnVuY3Rpb24ubmFtZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdGMuZnVuY3Rpb24uYXJndW1lbnRzICE9PSBcInN0cmluZ1wiO1xuICAgIH0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcblxuLy8gc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBuYW5vaWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGlmICghY2h1bmspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKTtcbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG52YXIgQ09NUExFWF9IRUFERVIgPSBcIlgtRXhwZXJpbWVudGFsLVN0cmVhbS1EYXRhXCI7XG5cbi8vIHNoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBhbm5vdGF0aW9ucykge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkID0gbmFub2lkLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXVxuICB9O1xuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IHZvaWQgMDtcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiAoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGxcbiAgfSkpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbXCJ0ZXh0XCJdKSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwW1widGV4dFwiXS5jb250ZW50IHx8IFwiXCIpICsgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdO1xuICAgIH1cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VfYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5cyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICBcInRvb2xfY2FsbHNcIlxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICBwcmVmaXhNYXBba2V5XS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpXG4gICAgfSkpO1xuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHNoYXJlZC9jYWxsLWNoYXQtYXBpLnRzXG5hc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgbWVzc2FnZXMsXG4gIGJvZHksXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIGFwcGVuZE1lc3NhZ2UsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgLi4uYm9keVxuICAgIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiAoX2EgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGF3YWl0IHJlc3BvbnNlLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChDT01QTEVYX0hFQURFUikgPT09IFwidHJ1ZVwiO1xuICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICByZWFkZXIsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWY6IGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdm9pZCAwLFxuICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlSWRcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoZmFsc2UpO1xuICAgIGxldCBzdHJlYW1lZFJlc3BvbnNlID0gXCJcIjtcbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiXG4gICAgfTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RyZWFtZWRSZXNwb25zZSArPSBkZWNvZGUodmFsdWUpO1xuICAgICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImZ1bmN0aW9uX2NhbGxcIl0gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSkge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJ0b29sX2NhbGxzXCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImNvbnRlbnRcIl0gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICBjb25zdCBwYXJzZWRGdW5jdGlvbkNhbGwgPSBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLmZ1bmN0aW9uX2NhbGw7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJmdW5jdGlvbl9jYWxsXCJdID0gcGFyc2VkRnVuY3Rpb25DYWxsO1xuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKSB7XG4gICAgICBjb25zdCBwYXJzZWRUb29sQ2FsbHMgPSBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLnRvb2xfY2FsbHM7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ0b29sX2NhbGxzXCJdID0gcGFyc2VkVG9vbENhbGxzO1xuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG59XG5cbi8vIHNoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6IGdldFN0cmVhbWVkUmVzcG9uc2UyLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzXG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UyKCk7XG4gICAgaWYgKFwibWVzc2FnZXNcIiBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmICgobWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDAgfHwgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikgJiYgKG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25DYWxsICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fCB0b29sQ2FsbHMuc29tZSgodG9vbENhbGwpID0+IHR5cGVvZiB0b29sQ2FsbCAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0ZvbGxvd2luZ1Jlc3BvbnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiYgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAmJiB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyA9IGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czI7XG4gICAgICBjb25zdCBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2U7XG4gICAgICBpZiAoKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikgJiYgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIGlmICghKHR5cGVvZiBmdW5jdGlvbkNhbGwgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIGZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgIGlmICghKHR5cGVvZiB0b29sQ2FsbHMgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyBmdW5jdGlvbnNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyKHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbnZhciBnZXRTdHJlYW1lZFJlc3BvbnNlID0gYXN5bmMgKGFwaSwgY2hhdFJlcXVlc3QsIG11dGF0ZSwgbXV0YXRlU3RyZWFtRGF0YSwgZXhpc3RpbmdEYXRhLCBleHRyYU1ldGFkYXRhUmVmLCBtZXNzYWdlc1JlZiwgYWJvcnRDb250cm9sbGVyUmVmLCBnZW5lcmF0ZUlkLCBvbkZpbmlzaCwgb25SZXNwb25zZSwgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgbXV0YXRlKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBmYWxzZSk7XG4gIGNvbnN0IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkID0gc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyA/IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzIDogY2hhdFJlcXVlc3QubWVzc2FnZXMubWFwKFxuICAgICh7IHJvbGUsIGNvbnRlbnQsIG5hbWUsIGZ1bmN0aW9uX2NhbGwsIHRvb2xfY2FsbHMsIHRvb2xfY2FsbF9pZCB9KSA9PiAoe1xuICAgICAgcm9sZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAuLi5uYW1lICE9PSB2b2lkIDAgJiYgeyBuYW1lIH0sXG4gICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsXG4gICAgICB9LFxuICAgICAgLi4udG9vbF9jYWxscyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgdG9vbF9jYWxsc1xuICAgICAgfVxuICAgIH0pXG4gICk7XG4gIGlmICh0eXBlb2YgYXBpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiY29udGVudFwiXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ1aVwiXSA9IGF3YWl0IHVpO1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYXdhaXQgY2FsbENoYXRBcGkoe1xuICAgIGFwaSxcbiAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQsXG4gICAgYm9keToge1xuICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgLi4uKF9hID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJvZHksXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uczogY2hhdFJlcXVlc3QuZnVuY3Rpb25zXG4gICAgICB9LFxuICAgICAgLi4uY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbFxuICAgICAgfSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LnRvb2xzICE9PSB2b2lkIDAgJiYge1xuICAgICAgICB0b29sczogY2hhdFJlcXVlc3QudG9vbHNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC50b29sX2Nob2ljZSAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgdG9vbF9jaG9pY2U6IGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlXG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uKF9iID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnNcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBtZXNzYWdlXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi5leGlzdGluZ0RhdGEgfHwgW10sIC4uLmRhdGEgfHwgW11dLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWRcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBpZEtleSA9IGlkICE9IG51bGwgPyBpZCA6IGhvb2tJZDtcbiAgY29uc3QgY2hhdEtleSA9IHR5cGVvZiBhcGkgPT09IFwic3RyaW5nXCIgPyBbYXBpLCBpZEtleV0gOiBpZEtleTtcbiAgY29uc3QgW2luaXRpYWxNZXNzYWdlc0ZhbGxiYWNrXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1IoXG4gICAgW2NoYXRLZXksIFwibWVzc2FnZXNcIl0sXG4gICAgbnVsbCxcbiAgICB7IGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzICE9IG51bGwgPyBpbml0aWFsTWVzc2FnZXMgOiBpbml0aWFsTWVzc2FnZXNGYWxsYmFjayB9XG4gICk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSKFxuICAgIFtjaGF0S2V5LCBcImxvYWRpbmdcIl0sXG4gICAgbnVsbFxuICApO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSKFtjaGF0S2V5LCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCB7IGRhdGE6IGVycm9yID0gdm9pZCAwLCBtdXRhdGU6IHNldEVycm9yIH0gPSB1c2VTV1IoW2NoYXRLZXksIFwiZXJyb3JcIl0sIG51bGwpO1xuICBjb25zdCBtZXNzYWdlc1JlZiA9IHVzZVJlZihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHlcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICBhcGksXG4gICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICBzdHJlYW1EYXRhLFxuICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHNcbiAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdDogKGNoYXRSZXF1ZXN0UGFyYW0pID0+IHtcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gY2hhdFJlcXVlc3RQYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gbWVzc2FnZXNSZWYuY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3IoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgZ2VuZXJhdGVJZFxuICAgIF1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG1lc3NhZ2UsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmdW5jdGlvbnMsXG4gICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sX2Nob2ljZSxcbiAgICAgIGRhdGFcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9LFxuICAgICAgICAuLi50b29scyAhPT0gdm9pZCAwICYmIHsgdG9vbHMgfSxcbiAgICAgICAgLi4udG9vbF9jaG9pY2UgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2hvaWNlIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkXVxuICApO1xuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoe1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29scyxcbiAgICAgIHRvb2xfY2hvaWNlXG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1JlZi5jdXJyZW50W21lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIikge1xuICAgICAgICBjb25zdCBjaGF0UmVxdWVzdDIgPSB7XG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbl9jYWxsIH0sXG4gICAgICAgICAgLi4udG9vbHMgIT09IHZvaWQgMCAmJiB7IHRvb2xzIH0sXG4gICAgICAgICAgLi4udG9vbF9jaG9pY2UgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2hvaWNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0Mik7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSxcbiAgICAgICAgLi4udG9vbHMgIT09IHZvaWQgMCAmJiB7IHRvb2xzIH0sXG4gICAgICAgIC4uLnRvb2xfY2hvaWNlICE9PSB2b2lkIDAgJiYgeyB0b29sX2Nob2ljZSB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzMiwgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzMjtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGUsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCBhcyB1c2VJZDIsIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IyIGZyb20gXCJzd3JcIjtcblxuLy8gc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgb25EYXRhXG59KSB7XG4gIHRyeSB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcbiAgICBzZXRDb21wbGV0aW9uKFwiXCIpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9KSxcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgfSxcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYXdhaXQgcmVzLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXMuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzLmhlYWRlcnMuZ2V0KENPTVBMRVhfSEVBREVSKSA9PT0gXCJ0cnVlXCI7XG4gICAgaWYgKGlzQ29tcGxleE1vZGUpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgICAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlciA9PT0gbnVsbFxuICAgICAgfSkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5mdW5jdGlvbiB1c2VDb21wbGV0aW9uKHtcbiAgYXBpID0gXCIvYXBpL2NvbXBsZXRpb25cIixcbiAgaWQsXG4gIGluaXRpYWxDb21wbGV0aW9uID0gXCJcIixcbiAgaW5pdGlhbElucHV0ID0gXCJcIixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yXG59ID0ge30pIHtcbiAgY29uc3QgaG9va0lkID0gdXNlSWQyKCk7XG4gIGNvbnN0IGNvbXBsZXRpb25JZCA9IGlkIHx8IGhvb2tJZDtcbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjIoW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb25cbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSMihcbiAgICBbY29tcGxldGlvbklkLCBcImxvYWRpbmdcIl0sXG4gICAgbnVsbFxuICApO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSMihbY29tcGxldGlvbklkLCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlMih2b2lkIDApO1xuICBjb25zdCBjb21wbGV0aW9uID0gZGF0YTtcbiAgY29uc3QgW2Fib3J0Q29udHJvbGxlciwgc2V0QWJvcnRDb250cm9sbGVyXSA9IHVzZVN0YXRlMihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZjIoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICBhcGksXG4gICAgICBwcm9tcHQsXG4gICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogeyAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycywgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzIH0sXG4gICAgICBib2R5OiB7XG4gICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHlcbiAgICAgIH0sXG4gICAgICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjIpID0+IG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpLFxuICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgIHNldEVycm9yLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uRGF0YTogKGRhdGEyKSA9PiB7XG4gICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLnN0cmVhbURhdGEgfHwgW10sIC4uLmRhdGEyIHx8IFtdXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIG11dGF0ZVN0cmVhbURhdGFcbiAgICBdXG4gICk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2syKFxuICAgIChjb21wbGV0aW9uMikgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZTIoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2syKFxuICAgIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICByZXR1cm4gY29tcGxldGUoaW5wdXQpO1xuICAgIH0sXG4gICAgW2lucHV0LCBjb21wbGV0ZV1cbiAgKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0aW9uLFxuICAgIGNvbXBsZXRlLFxuICAgIGVycm9yLFxuICAgIHNldENvbXBsZXRpb24sXG4gICAgc3RvcCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGFcbiAgfTtcbn1cblxuLy8gcmVhY3QvdXNlLWFzc2lzdGFudC50c1xuaW1wb3J0IHsgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50KHtcbiAgYXBpLFxuICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTMoW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlMyhcIlwiKTtcbiAgY29uc3QgW3RocmVhZElkLCBzZXRUaHJlYWRJZF0gPSB1c2VTdGF0ZTModm9pZCAwKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlMyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUzKHZvaWQgMCk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgc2V0SW5wdXQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChldmVudCwgcmVxdWVzdE9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZXZlbnQpO1xuICAgIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTdGF0dXMoXCJpbl9wcm9ncmVzc1wiKTtcbiAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiBbXG4gICAgICAuLi5tZXNzYWdlczIsXG4gICAgICB7IGlkOiBcIlwiLCByb2xlOiBcInVzZXJcIiwgY29udGVudDogaW5wdXQgfVxuICAgIF0pO1xuICAgIHNldElucHV0KFwiXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4uaGVhZGVycyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAuLi5ib2R5LFxuICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgIHRocmVhZElkOiAoX2IgPSB0aHJlYWRJZFBhcmFtICE9IG51bGwgPyB0aHJlYWRJZFBhcmFtIDogdGhyZWFkSWQpICE9IG51bGwgPyBfYiA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuICAgICAgICAvLyBvcHRpb25hbCByZXF1ZXN0IGRhdGE6XG4gICAgICAgIGRhdGE6IHJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiByZXF1ZXN0T3B0aW9ucy5kYXRhXG4gICAgICB9KVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShcbiAgICAgICAgcmVzdWx0LmJvZHkuZ2V0UmVhZGVyKClcbiAgICAgICkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9tZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMyLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgIHJvbGU6IHZhbHVlLnJvbGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudFswXS50ZXh0LnZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkYXRhX21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VzMixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9hMiA9IHZhbHVlLmlkKSAhPSBudWxsID8gX2EyIDogXCJcIixcbiAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMyW21lc3NhZ2VzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ubWVzc2FnZXMyLnNsaWNlKDAsIG1lc3NhZ2VzMi5sZW5ndGggLSAxKSwgbGFzdE1lc3NhZ2VdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gbmV3IEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVycm9yT2JqKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgICAgc2V0RXJyb3IoZXJyb3IyKTtcbiAgICB9XG4gICAgc2V0U3RhdHVzKFwiYXdhaXRpbmdfbWVzc2FnZVwiKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICB0aHJlYWRJZCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBzdWJtaXRNZXNzYWdlLFxuICAgIHN0YXR1cyxcbiAgICBlcnJvclxuICB9O1xufVxuZXhwb3J0IHtcbiAgZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCxcbiAgdXNlQ2hhdCxcbiAgdXNlQ29tcGxldGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwidmFsdWUiLCJFcnJvciIsInR5cGUiLCJmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0IiwiZnVuY3Rpb25fY2FsbCIsImFyZ3VtZW50cyIsImRhdGFTdHJlYW1QYXJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJtYXAiLCJwYXJ0IiwicGFyc2VTdHJlYW1QYXJ0IiwibGluZSIsImZpcnN0U2VwYXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwicHVzaCIsInN0cmVhbVBhcnRzMiIsImRlY29kZSIsInN0cmVhbSIsInNwbGl0IiwiZmlsdGVyIiwic3RyZWFtUGFydCIsImNhbmNlbCIsImN1c3RvbUFscGhhYmV0IiwibmFub2lkIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZWQiLCJCb29sZWFuIiwiQ09NUExFWF9IRUFERVIiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZW5lcmF0ZUlkIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiY3JlYXRlZEF0IiwicHJlZml4TWFwIiwiZGF0YSIsIm1lc3NhZ2VfYW5ub3RhdGlvbnMiLCJjdXJyZW50IiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInRvb2xDYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lc3NhZ2VQcmVmaXhLZXlzIiwiZm9yRWFjaCIsImtleSIsIm1lcmdlZCIsIm1lc3NhZ2VzIiwiY2FsbENoYXRBcGkiLCJhcGkiLCJib2R5IiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwiYXBwZW5kTWVzc2FnZSIsInJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSIsIm9uUmVzcG9uc2UiLCJvblVwZGF0ZSIsIl9hIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsInN0cmluZ2lmeSIsInNpZ25hbCIsImNhdGNoIiwiZXJyIiwib2siLCJnZXRSZWFkZXIiLCJpc0NvbXBsZXhNb2RlIiwiZ2V0Iiwic3RyZWFtZWRSZXNwb25zZSIsInJlcGx5SWQiLCJkb25lIiwic3RhcnRzV2l0aCIsInBhcnNlZEZ1bmN0aW9uQ2FsbCIsInBhcnNlZFRvb2xDYWxscyIsInByb2Nlc3NDaGF0U3RyZWFtIiwiZ2V0U3RyZWFtZWRSZXNwb25zZSIsImdldFN0cmVhbWVkUmVzcG9uc2UyIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbCIsImNvbnNvbGUiLCJ3YXJuIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2UiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsUmVzcG9uc2UiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyIiwiZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzIiwic3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UiLCJjaGF0UmVxdWVzdCIsIm11dGF0ZSIsIm11dGF0ZVN0cmVhbURhdGEiLCJleGlzdGluZ0RhdGEiLCJleHRyYU1ldGFkYXRhUmVmIiwibWVzc2FnZXNSZWYiLCJzZW5kRXh0cmFNZXNzYWdlRmllbGRzIiwiX2IiLCJwcmV2aW91c01lc3NhZ2VzIiwiY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQiLCJ0b29sX2NhbGxfaWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsImNoYXRSZXF1ZXN0MiIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwibWVzc2FnZXMyIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VJZDIiLCJ1c2VSZWYyIiwidXNlU3RhdGUyIiwidXNlU1dSMiIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJyZXN1bHQiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGlvbjIiLCJkYXRhMiIsImNvbXBsZXRlIiwidXNlU3RhdGUzIiwiZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImV2ZW50Iiwic3VibWl0TWVzc2FnZSIsInJlcXVlc3RPcHRpb25zIiwiY2FsbCIsIl9hMiIsImVycm9yT2JqIiwiZXJyb3IyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;